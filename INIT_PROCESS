RELEASE AFTER 0.9 pre 9
7. Configuration
7.1 ActorDB configuration files
ActorDB configuration files:

app.config: where to store data, mysql protocol port and thrift port.
vm.args: set name of node (also erlang vm tweak parameters, which you should probably leave default).
app.config and vm.args need to be set on every node.

Managing nodes and groups of servers (clusters) running ActorDB since version <INSERT_RELEASE> is managed via actordb_console program. Before using ActorDB you have to initialize it via inputing console commands or execute a config file.

On install, default configuration files are placed in /etc/actordb or whichever is equivalent for your platform.

7.2 actordb_console

Running actordb_console program with flag -h gives you an output with instructions how to properly run it:

./actordb_console -h

Call with: actordb_console -u username -p password IP[:ThriftPort]
Flags:
  -h   print this help and exit
  -u   username
  -p   password
  -f   <file> execute statements from file and exit


7.3 Initialization process

SQL file contains the SQL command and control sequence. 
You start by creating groups of servers with standard MySQL management statements with inserting values into predefined global actor with schema that has two tables:

Describing groups:
+------------+----------+------+-----+---------+----------------+
| Field       |Type     | Null  | Key|Default | Extra            |
+------------+----------+------+-----+---------+----------------+
| name      | TEXT   | NO   |       |            |                    |
| type        | TEXT   | NO   |       |’cluster’|                    |
+------------+----------+------+-----+---------+----------------+

Describing nodes:
+----------------+----------+------+-----+---------+----------------+
| Field            |Type     | Null  | Key | Default | Extra         |
+----------------+----------+-------+-----+---------+----------------+
| name           | TEXT   | NO   |        |           |                     |
| group_name| TEXT   | NO   |        |           |                     |
+-----------------+----------+------+-----+---------+----------------+

The initialization block starts with a keyword use config and executes with commit. In between are the insert and create user statements. For example:
use config
INSERT INTO groups VALUES ('grp1','cluster')
INSERT INTO nodes VALUES ('testnd@127.0.0.1:44380','grp1')
CREATE USER 'root' IDENTIFIED BY 'rootpass'
commit

The root user that we created here is able to change schema or change configuration. Once initialization is done console will be connected as this user. Every user created in this stage will have all privileges.Which means you should not create more than one in this segment. Add additional users later.

localnode() function is returning the name of the node we are connected to e.g. testnd@127.0.0.1:44380.

Continuing with use config block we now create a user for querying. 

CREATE USER 'myuser' IDENTIFIED BY 'mypass'
GRANT read,write ON * to 'myuser'
commit

This user has access to all Actor types. We can also limit a users access to actors. 

CREATE USER 'myseconduser' IDENTIFIED BY 'mypass'
GRANT read,write ON type1 to 'myuser'
commit

Because type1 actor does not exist at the moment, we would get an error message.

Error: {ok,{error,{100,<<“invalid_actor_type">>}}}

Let us proceed with creating schema for that actor type.
use schema
actor type1
CREATE TABLE tab (id INTEGER PRIMARY KEY, txt TEXT)
CREATE TABLE tab1 (id INTEGER PRIMARY KEY, txt TEXT)
ALTER TABLE tab ADD i INTEGER
CREATE TABLE tabx (id INTEGER PRIMARY KEY CHECK (typeof(id) == 'integer'), txt TEXT CHECK (typeof(id) == 'text'))
commit

We can now go back and grant read and write privileges to the user ‘myseconduser’ on actor type type1.

The schema can be changed at any time, but only by adding SQL statements to the end of the list. Every time a new actor is created, the entire list of SQL commands will be executed to create the schema. If schema changes while ActorDB is running, actors will be updated by applying the new statements in the list. If you add new statements in the middle of the list, you will have inconsistent schemas.

For further examples check https://github.com/biokoda/actordb/blob/master/etc/init.sql.



