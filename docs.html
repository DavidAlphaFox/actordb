<!DOCTYPE html>
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head prefix="og: http://ogp.me/ns#">
        <!--<meta charset="utf-8">-->
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>ActorDB | Documentation</title>        
        <meta name="description" content="ActorDB is strongly consistent, distributed and horizontally scalable. Unlike traditional monolithic databases, ActorDB is made out of any number of independent and concurrent SQL databases called actors.">
        <meta name="viewport" content="width=device-width">
        <meta property="og:title" content="ActorDB | Documentation" />
        <meta property="og:description" content="ActorDB is strongly consistent, distributed and horizontally scalable. Unlike traditional monolithic databases, ActorDB is made out of any number of independent and concurrent SQL databases called actors." />
        <meta property="og:site_name" content="ActorDB" />
        <meta property="og:type" content="website" />
        <meta property="og:url" content="http://www.actordb.com/" />
        <meta property="og:image" content="http://www.actordb.com/imgs/actordb_fb_logo.png" />
        <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
        <link rel="stylesheet" href="css/bootstrap.css">
        <link rel="stylesheet" href="css/actordb-website.css">
        <script src="js/vendor/modernizr-2.6.2-respond-1.1.0.min.js"></script>
        <script src="js/vendor/jquery-1.10.1.min.js"></script>
        <style>
            .block {
                display:block !Important;
            }
        </style>
        <script>
            $(document).ready(function(){
                $("#mobile_menu").click(function(evt){
                    $(this).siblings(".navigation").toggleClass("block");
                });
            });
        </script>
        <!--[if gte IE 9]>
          <style type="text/css">
            .gradient {filter: none;}
          </style>
        <![endif]-->
    </head>    
    <body id="view320logo" >
        <!--[if lt IE 9]>
            <p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
        <![endif]-->
        <div class="header">
            <div class="pagewrapper clearfix">
                <a href="" class="global-header_logo"></a>
                <a href="" class="global320-header_logo_text global-header_logo_text"></a>
                <ul class="navigation">
                    <li ><a href="index.html">Home</a></li>
                    <li  class="sel"><a href="docs-about.html">Documentation</a></li>
                    <li><a target="_blank" href="https://www.github.com/biokoda/actordb">Source</a></li>
                    <li class="  right"><a target="_blank" href="downloads.html">Downloads</a></li>
                </ul>
                <span id="mobile_menu" class="menu"></span>
            </div>
        </div>

        <div class="pagecontainer">
    <div class="pagewrapper clearfix">
        <div class="leftmenu">
            <div class="menutitle"><a href="docs-about.html">1. ABOUT</a></div>
            <ul class="menu">
            <!--    <li><a href="" class="link">1. About</a></li>-->
            </ul>
            <div class="menutitle"><a href="docs-howitworks.html">2. HOW IT WORKS</a></div>
            <ul class="menu">
                <li><a href="docs-howitworks.html#overview" class="link">2.1 Overview</a></li>
                <li><a href="docs-howitworks.html#nodesyny" class="link">2.2 Node sync</a></li>
                    <ul class="level3">
                        <li><a href="docs-howitworks.html#h_221" class="link">2.2.1 Global state</a></li>
                        <li><a href="docs-howitworks.html#h_222" class="link">2.2.2 Actors</a></li>
                        <li><a href="docs-howitworks.html#h_223" class="link">2.2.3 Multi-actor transactions</a></li>
                    </ul>
                <li><a href="docs-howitworks.html#dbengine" class="link">2.3 Database engine</a></li>
            </ul>
            <div class="menutitle"><a href="docs-querymodel.html">3. QUERY MODEL</a></div>
            <ul class="menu">
                <li><a href="docs-querymodel.html#query_actor" class="link">3.1 ACTOR statement</a></li>
                    <ul class="level3">
                        <li><a href="docs-querymodel.html#h_311" class="link">3.1.1 Single actor</a></li>
                        <li><a href="docs-querymodel.html#h_312" class="link">3.1.2 Multiple actors</a></li>
                        <li><a href="docs-querymodel.html#h_313" class="link">3.1.3 All actors of a type</a></li>
                        <li><a href="docs-querymodel.html#h_314" class="link">3.1.4 Loop over actors</a></li>
                    </ul>
                <li><a href="docs-querymodel.html#query_variables" class="link">3.2 Variables</a></li>
                    <ul class="level3">
                        <li><a class="link">3.2.1 Appending columns to result</a></li>                        
                    </ul>
                <li><a href="docs-querymodel.html#query_pragma" class="link">3.3 PRAGMA statement</a></li>
            </ul>
            <div class="menutitle"><a href="docs-kvstore.html">4. KEY/VALUE STORE</a></div>
            <ul class="menu">                                
            </ul>
            <div class="menutitle"><a href="docs-examples.html">5. EXAMPLES</a></div>
            <ul class="menu">
                <li><a href="docs-examples.html#example_webforum" class="link">5.1 Web forum</a></li>                
            </ul>
            <div class="menutitle"><a href="docs-configuration.html">6. CONFIGURATION</a></div>
            <ul class="menu">
            </ul>
        </div>
        <div class="content">

   				            <h1 id="about" class="pagetitle">1. About</h1>                    
            <!--<h2 class="pagesubtitle">1. Why</h2>                    -->


                <p class="pagetext"></p>
                <p class="pagetext">ActorDB is a distributed SQL database. To understand why this is important we have to start with traditional SQL databases.</p>

                <p class="pagetext">Note that terms node and server will be used interchangeably. </p>

                <p class="pagetext">Traditional SQL databases are monolithic. They work very well in the context of a single server, but are limited to that server. Of course they can work master/slave or master/master, but the entire dataset still needs to be on each server. Even if the dataset is not too large, traditional SQL databases require extremely complex and broad locking mechanisms for transactions. Once the query load is too high or the dataset is too large, some drastic changes need to be made in how you use your database.</p>

                <p class="pagetext">Data will need to be denormalized. Code complexity will have to go up. A lot of time will be spent trying to keep your head above water. Eventually if you still keep growing, you have to turn to database sharding. Dramatically increasing complexity of everything that involves using the database. </p>

                <p class="pagetext">ActorDB on the other hand allows you to start out with a database that is fully normalised within an actor unit and scale that database horizontally over as many servers as you need. No single points of failure or global locks. Transactions only affect the actors that participate in them. </p>

            <h1 id="howitworks" class="pagetitle">2. How it works</h1>
            

            <h2 id="overview" class="pagesubtitle">2.1 Overview</h2>
            <div class="clearfix imgholder">
                <img class="img_left" src="imgs/single_cluster.png" alt=""/>
                <img class="img_right" src="imgs/multiple_cluster.png" alt=""/>
            </div>
                <p class="pagetext"></p>
                <p class="pagetext">ActorDB is organised into clusters of 3 nodes. There can be as many clusters as you wish. Actors themselves are organised into shards. Logically a shard is a chunk of hash namespace. It is a special type of actor that holds a list of regular actors. Shards live within clusters and so do their actors.</p>

                <p class="pagetext">An actor is a mini fully relational SQL database. It has a master node that processes reads and writes, it has slave nodes on other servers in the cluster that receive writes from master. Writes are replicated using a 2 phase commit. If a server is offline, one of the slaves will automatically become a master for that actor. As long as a majority of servers in a cluster are online, writes will succeed. </p>

                <p class="pagetext">A single actor is not scalable, it is fast enough. The database as a whole is completely horizontally scalable, because actors are independent of each other.</p>

            <hr class="hr14color" />
            
            <h2 id="nodesyny" class="pagesubtitle">2.2 Node synchronisation</h2>
            <h3 class="pagesubtitle">2.2.1 Global state</h3>
                <p class="pagetext">ActorDB is designed around having to do the least possible inter-server synchronisation. That means each server should be as independent as possible and global state and the changing of that global state should be minimised. </p>
                <p class="pagetext">Global state for ActorDB:</p>
                <div class="pagetext">
                    <ol>
                        <li>1. List of nodes (changed manually by user).</li>
                        <li>2. Database schema (changed manually by user).</li>
                        <li>3. List of shards and which node owns which shard (caused by change in list of nodes).</li>
                        <li>4. uniqid current max value (set automatically).</li>
                        <li>5. Who is master (changed when it goes offline).</li>
                    </ol>
                </div>

                <p class="pagetext"></p>

                <p class="pagetext">Servers are synchronised through knowing who the master is and which shard belongs to whom.</p>
                <p class="pagetext">Data is versioned and atomic. All changes are done through the master. A master does a 2 phase commit to save it. </p>

                <p class="pagetext"></p>

                <div class="pagetext">
                    Sequence of events:
                    <ol>
                        <li>1. Node starts, generates random number which does not change for the duration of its run.</li>
                        <li>2. It connects to all other nodes in cluster to find out what current state is and what their random numbers are.</li>
                        <li>3. If no state, or if can not connect to master it will check if its random number is highest of all.</li>
                        <li>4. If it is not, it waits 5s and goes back to step 2. If it has highest number, it tries to do a 2 phase commit to become master. If successful that node becomes master. A successful 2 phase commit means a majority of nodes.</li>
                        <li>5. If there is no list of shards, master node will create them and assign them to servers.</li>
                    </ol>
                </div>

                <p class="pagetext"></p>

                <p class="pagetext">
                Shard data is then left unchanged until a new cluster is added. In that case, new nodes will start stealing shards from existing nodes. If there are too few shards they will be split in half. 
                </p>

                <p class="pagetext">
                The act of stealing and splitting shards is initiated between the servers themselves and global state is only changed when it is done. When that happens the master is informed, it will fix the list of shards and initiate a 2 phase commit to save it.
                </p>

                <p class="pagetext">Problematic scenarios:</p>

                <p class="pagetext">
                Q: A node shuts down in the middle of a commit it has stale or wrong data when it starts again. <br/>
                A: On startup nodes will not start until they have verified and updated their state.
                </p>

                <div class="pagetext">
                Q: A node disconnects in the middle of a commit and later reconnects. It has committed data that was incorrect. <br/>
                A: The master does periodic rebroadcasts of state. Eventually it will correct itself. But it had bad data for X seconds:
                <ol>
                    <li>1. Bad data for shard locations: shards have moved someplace else and actor requests will be routed to the wrong place. That is an event that only happens as a result of user action when adding clusters. The way ActorDB is designed that generally should not cause any errors however. For every actor that has moved somewhere else, a marker is left behind where it moved to.</li>
                    <li>2. uniqid max value was wrong. That information is irrelevant to every server other than master. </li>
                    <li>3. Master has changed. Any state changes happen through master, if this reconnected server tries to change state it will connect to what it thinks is the master. If that server is not actually master, it will forward the request to what it thinks is master. That might look like a potential endless loop if there are no actual masters, but that is not the case. A master always emerges when there is a majority, if there is no majority state changes fail.</li>
                </ol>
                 </div>
              
                <p class="pagetext"></p>
                <p class="pagetext">                        
                Our current model of handling global state is thus simple, but "should" be sufficient. We are in the process of building more thorough tests at the moment and this model is subject to change if it proves insufficient.</p>

                <hr class="hr14colorsmalmargin" />

                <h3 class="pagesubtitle">2.2.2 Actors</h3>

                <p class="pagetext">All ActorDB requests are always sent to an actor. Steps from receiving request sending request to actor:</p>
                <div class="pagetext">
                    <ol>
                        <li>1. Calculate a hash of actor name.</li>
                        <li>2. Check the hash table of shards to find which node that actor lives in.</li>
                        <li>3. Send request to what should be master node.</li>
                        <li>4. If what should be master node is actually not, request will be redirected to the actual master.</li>
                    </ol>
                </div>
                <p class="pagetext"></p>
                <p class="pagetext">When a request arrives to an actor on a server which was previously inactive on it:</p>
                <p class="pagetext">1. Open its isolated database. Read last write numbers. It marks itself an unconfirmed master, because it has a request queued up.<br/>
2. Verify its state. Ask all other nodes in the cluster what their state is for that actor.
</p>
                <p class="pagetext"></p>
                <p class="pagetext">Possible scenarios:</p>
                <div class="pagetext">
                    <ol>
                        <li>1. One of them is confirmed master already, current node turns itself into a slave. Any queued up requests are redirected to master.</li>
                        <li>2. No nodes are confirmed or unconfirmed master, it will assume master role.</li>
<li>3. One or more nodes are unconfirmed masters. Generally this should be a very rare event, because requests always get routed with consistent hashing to specific nodes. But since they are all unconfirmed, they are all currently trying to verify their state at the same time. Every one of them will do a sort of node names and pick the first one.</li>
<li>4. It finds multiple confirmed masters. This should be impossible. In case it happens through code error, it will tell other nodes to close actor.Note that even if actor somehow gets in this state, write logic will prevent writes coming from the wrong direction (a master receives a write from what it thinks is a slave). The worst case scenario will be a failed write request and not a conflicted actor database.</li>
                    </ol> 
                </div>
                <p class="pagetext">
</p>
                <p class="pagetext">What if a node was offline for a while and missed some writes? <br/>It will find a node that has the correct version of the database and copy it from there. ActorDB can execute reads and writes to an actor database while copying it over to another node.
</p>
                <p class="pagetext"></p>
                <p class="pagetext"></p>

                <hr class="hr14colorsmalmargin" />
            <h3 class="pagesubtitle">2.2.3 Multi-actor transactions</h3>
            
            <p class="pagetext">Multi-actor transactions need to be ACID compliant. They are executed by a transaction manager. The manager is itself an actor. It has name and a transaction number that is incremented for every transaction.</p>
            <p class="pagetext">Sequence of events from the transaction manager point of view:</p>
            <div class="pagetext">
                <ol>
                    <li>1. Start transaction by writing the number and state (uncommitted) to transaction table of transaction manager actor.</li>
<li>2. Go through all actors in the transaction and execute their belonging SQL to check if it can execute, but do not commit it. If actor successfully executes SQL it will lock itself (queue all reads and writes).</li>
<li>3. All actors returned success. Change state in transaction table for transaction to committed. </li>
<li>4. Inform all actors that they should commit.</li>
                </ol>
            </div>
            <p class="pagetext"></p>
            <p class="pagetext">Sequence of events from an actors point of view:</p>
            <div class="pagetext">
                <ol>
                    <li>1. Actor receives SQL with a transaction ID, transaction number and which node transaction manager belongs to. </li>
<li>2. Store the actual SQL statement with transaction info to a transaction table (not execute it). </li>
<li>3. Once it is stored, the SQL will be executed but not committed. If there was no error, return success.</li>
<li>4. Actor waits for confirm or abort from transaction manager. It will also periodically check back with the transaction manager in case the node where it was running from went down and confirmation message is lost.</li>
<li>5. Once it has a confirmation or abort message it executes it and unlocks itself.</li>
                </ol>
            </div>
            <p class="pagetext"></p>
            <p class="pagetext">Problem scenarios:</p>
            <div class="pagetext">
                <ol>
                    <li>1. Node where transaction manager lives goes down before committing transaction: Actors will be checking back to see what state a transaction is in. If transaction manager actor resumes on another node and sees an uncommitted transaction, it will mark it as aborted. Actors will in turn abort the transaction as well.</li>
<li>2. Node where transaction manager lives goes down after committing transaction to local state, but before informing actors that transaction was confirmed. Actors checking back will detect a confirmed transaction and commit it.</li>
<li>3. Node where one or more actors live goes down after confirming that they can execute transaction. The actual SQL statements are stored in their databases. The next time actors start up, they will notice that transaction. Check back with the transaction manager and either commit or abort it.</li>
                </ol>
            </div>
            <p class="pagetext"></p>
            <p class="pagetext">Multi-actor transactions thus have a significantly higher overhead then single actor transactions.
</p>
            <p class="pagetext"></p>
            <hr class="hr14color" />

            <h2 id="dbengine" class="pagesubtitle">2.3 Database engine</h2>

            <p class="pagetext">ActorDB does not reinvent the storage engine. It relies on one of the most well tested and stable pieces of code in use: sqlite</p>

            <p class="pagetext">Now if you've had experience with sqlite you are likely thinking that is a terrible idea. Sqlite is not scalable. That is true. Sqlite is not scalable, but it is fast if configured to be. Remember that each actor in ActorDB is completely isolated. Every actor is a completely separate sqlite instance. Sqlite is not where ActorDB scalability comes from.</p>

            <p class="pagetext"></p>

            <h1 id="querymodel" class="pagetitle">3. Query model</h1>

            <h2 id="query_actor" class="pagesubtitle">3.1 ACTOR statement</h2>

            <h3 class="pagesubtitle">3.1.1 Single actor</h3>

            <p class="pagetext">Queries to ActorDB always need to be directed to an actor. For this reason ActorDB uses the "ACTOR" command.</p>

            <p class="pagetext">Basic query, sent as a single string to the database:</p>

            <div class="structure">
                <pre>
ACTOR actortype(actorid) create;
SELECT * FROM sometable;
                </pre>
            </div>

            <p class="pagetext">
actorid - id that you have set for actor.<br/>
<br/>
actortype - type of actor. You can have multiple types of actors with completely different schemas.<br/>
<br/>
create (flag) - if actorid does not exist, create and actor with this id. If you don't wish to create it, ommit this flag.<br/>
<br/>
sometable - a table defined in actortype schema.<br/>
<br/>
You can update multiple types of actors in a single query.
            </p>

            <div class="structure">
                <pre>
ACTOR actortype1(actorid1) create;
INSERT INTO table1 VALUES (1,'some text');
ACTOR actortype2(actorid2) create;
INSERT INTO tableX VALUES (3,'something else');
                </pre>
            </div>

            <p class="pagetext">
                This is a transaction over two actors. They will both be updated or none of them will.
            </p>

            <hr class="hr14colorsmalmargin" />

            <h3 class="pagesubtitle">3.1.2 Multiple actors</h3>            

            <div class="structure">
                <pre>
ACTOR actortype(actorid1,actorid2,actorid3) create;
INSERT INTO sometable VALUES (1,'txt');
                </pre>
            </div>

            <p class="pagetext">
                Insert will execute on all three actors of type "actortype" inside a transaction. If an actor does not exist, it will be created.
            </p>

            <hr class="hr14colorsmalmargin" />

            <h3 class="pagesubtitle">3.1.3 All actors of a type</h3>            

            <div class="structure">
                <pre>
ACTOR type1(*);
INSERT INTO sometable VALUES (1,'txt');
                </pre>
            </div>

            <p class="pagetext">
                This query will run on all actors of type1. If there are many actors of type1 calling this is not recommended.
            </p>

            <hr class="hr14colorsmalmargin" />

            <h3 class="pagesubtitle">3.1.4 Loop over actors</h3>            

            <p class="pagetext">
                When your list of actors over which you wish to run a query is stored in another actor.
            </p>

<div class="structure">
                <pre>                    
ACTOR type1(actor);
{{ACTORS}}SELECT * FROM table2;
ACTOR type1(for X.txt in ACTORS) create;
insert into sometable values (1,'{{X.val}}');
                </pre>
            </div>

            <p class="pagetext">
                What is going on line by line:
            </p>

            <p class="pagetext">
                <ol>
                    <li>1. Select a single actor of type1. It must exist because there is no create flag.</li>
                    <li>2. Run a select over table2 and store the result in a variable ACTORS</li>
                    <li>3. For every row in ACTORS, read the .txt column which contains the name of an actor. These actors are of type "type1". If they do not exist, they will be created.</li>
                    <li>4. For every actor in ACTORS, insert a row into "sometable". Use another column from current row of ACTORS.</li>
                </ol>
            </p>

            <p class="pagetext"></p>

            <h2 id="query_variables" class="pagesubtitle">3.2 Variables</h2>

            <p class="pagetext">As mentioned in 3.1.4 ActorDB uses variables to pass data around when doing queries over multiple actors.</p>

            <p class="pagetext">There are also special variables available:</p>

            <p class="pagetext"> ActorDB will replace this with a unique integer id.  is always increasing globally across all servers every time it is used. Calls to one server are guaranteed to always have a bigger id, calls to different servers are not, but are guaranteed to be unique.
</p>

            <div class="structure">
                <pre>
ACTOR type1(actor);
INSERT INTO table VALUES ({{uniqid}}, 'sometext');
                </pre>
            </div>


            <p class="pagetext">{{uniqid.X}} will also insert a unique integer value, but can be referenced in multiple places:</p>


            <div class="structure">
                <pre>
ACTOR type1({{uniqid.myid}}) create;
INSERT INTO table VALUES (1,'actor created with id {{uniqid.myid}}');
                </pre>
            </div>



            <p class="pagetext">{{curactor}} when executing statements over multiple actors, {{curactor}} will always reference the current executing actor. It will only work in queries over multiple actors.</p>


            <div class="structure">
                <pre>
ACTOR type1(actor1,actor2,actor3);
INSERT INTO table VALUES (1,'my id is {{curactor}}')
                </pre>
            </div>



            <p class="pagetext">{{RESULT}} when executing a read query across multiple actors, you have to add the result to this variable:</p>


            <div class="structure">
                <pre>
ACTOR type1(actor1,actor2,actor3);
{{RESULT}}SELECT * FROM tablex;
                </pre>
            </div>



            <p class="pagetext">Result set will contain an additional column with every row named "actor", which will contain the name of actor to which result row belongs to. Do not use  {{RESULT}}  in queries to a single actor.
</p>

            <p class="pagetext"></p>

            <h3 class="pagesubtitle">3.2.1 Appending columns to result</h3>            

            <p class="pagetext">Say you have a forum thread actor. Every post in the thread contains the user id of the user that wrote the message. But when reading the thread you need more than just the user id, you need his username:
</p>


            <div class="structure">
                <pre>
ACTOR thread(1);
{{RESULT}}SELECT * FROM thread;
ACTOR user(for X.userid in RESULT);
{{INFO}}SELECT * FROM userinfo WHERE id=1;
{{X.username=INFO.name}}
                </pre>
            </div>


            <p class="pagetext">Explanation line by line:</p>

            <p class="pagetext">
                <ol>
                    <li>1. Switch to thread actor with id 1</li>
                    <li>2. Read all posts in thread table and store in "RESULTS" variable</li>
                    <li>3. Loop over all posts by userid column and switch to user with that id.</li>
                    <li>4. Read from his userinfo table</li>
                    <li>5. Take name from "INFO" and store into username column of result. This column does not need to exist in thread table. It will be added.</li>

                </ol>
            </p>

            <p class="pagetext"></p>


            <h2 id="query_pragma" class="pagesubtitle">3.3 PRAGMA statement</h2>

            <p class="pagetext">PRAGMA commands do specific operations or queries over one or many actors.</p>

            <h3 class="pagesubtitle">PRAGMA list</h3>                        

            <p class="pagetext">Will list all actors of a certain type</p>



            <div class="structure">
                <pre>
ACTOR thread(*);
PRAGMA list;
                </pre>
            </div>


            <hr class="hr14colorsmalmargin" />

            <h3 class="pagesubtitle">PRAGMA delete</h3>                        

            <p class="pagetext">Will delete all actors listed in "ACTOR" statement.</p>



            <div class="structure">
                <pre>
ACTOR thread(thread1,thread2);
PRAGMA delete;                
                </pre>
            </div>


            <hr class="hr14colorsmalmargin" />

            <h3 class="pagesubtitle">PRAGMA exists</h3>                        

            <p class="pagetext">Will return true or false if actor exists. Works only on a single actor.</p>



            <div class="structure">
                <pre>
ACTOR thread(thread1);
PRAGMA exists;
                </pre>
            </div>


            <hr class="hr14colorsmalmargin" />

            <h3 class="pagesubtitle">PRAGMA count</h3>                        

            <p class="pagetext">Will count number of existing actors of a type.</p>



            <div class="structure">
                <pre>
ACTOR thread(*);
PRAGMA count;
                </pre>
            </div>


            <hr class="hr14colorsmalmargin" />

            <h3 class="pagesubtitle">PRAGMA copy</h3>                        

            <p class="pagetext">Will create a copy of an actor with a different name. Actor listed in "ACTOR" statement is new actor, actor listed in PRAGMA statement is actor that will be copied over. The destination name of actor should not exist. If it does it will either be overwritten or operation will fail, because that actor is actively executing requests.</p>



            <div class="structure">
                <pre>
ACTOR thread(threadCopyTo);
PRAGMA copy=threadCopyFrom;
                </pre>
            </div>


            <p class="pagetext"></p>

            <h1 id="kvstore" class="pagetitle">4. Key/Value store</h1>

            <p class="pagetext">ActorDB can also act as a key/value store by maintaining a sharded table across all clusters. The syntax is a bit verbose and not idiot proof, but it is quite powerful.</p>

            <p class="pagetext">In schema.yaml file you can define a table like this:</p>


            <div class="structure">
                <pre>
mykvtype: 
 type: kv
 schema: 
  - CREATE TABLE actors (id TEXT UNIQUE, hash INTEGER, val INTEGER)
                </pre>
            </div>


            <p class="pagetext">mykvtype is the key/value namespace. You can have multiple namespaces with different table schemas.</p>
            <p class="pagetext">kv specifies this type as a sharded key/value table.</p>
            <p class="pagetext">Table must be named "actors" and it must have id and hash columns. id is key, hash is hash of id, everything after that is up to you.
</p>
            <p class="pagetext">Note: Only a single table is supported at the moment.</p>
            <p class="pagetext">Inserting a value:</p>


            <div class="structure">
                <pre>
ACTOR mykvtype(mykey);
insert into actors values ('mykey',{{hash(mykey)}},1);
                </pre>
            </div>


            <p class="pagetext">Very similar to how actors are queried. First line sets namespace and id. Second line is what gets executed on shard. First two columns must be written like above. If string for key (mykey) is not written the same in all three places, the KV store will not work correctly.</p>
            <p class="pagetext">You can return an entire KV namespace with a simple query:</p>


            <div class="structure">
                <pre>
ACTOR mykvtype(*);
{{RESULT}}SELECT * FROM actors;
                </pre>
            </div>


        

            <h2 class="pagesubtitle">4.1 Use case: reliable distributed counters</h3>                        

            <p class="pagetext">Say you have an analytics application that needs to be able count pageviews. Single points of failure or data loss are out of the question. You basically have two operations: increment and read counter.
</p>
            <p class="pagetext">If you have 2 clusters of 3 servers. Create 12 counter IDs (24 would probably be better).
</p>
            <p class="pagetext">Pick key for increment: N = RandomNumber % 12.
</p>
            <p class="pagetext">Increment</p>


            <div class="structure">
                <pre>
ACTOR mykvtype(N);
UPDATE actors SET val = val+1 WHERE id='N';
                </pre>
            </div>


            <p class="pagetext">Read counters</p>


            <div class="structure">
                <pre>
ACTOR mykvtype(1,2,3,4,5,6,7,8,9,10,11,12);
{{RESULT}}SELECT * FROM actors where id='{{curactor}}';
                </pre>
            </div>


            <p class="pagetext">This will return row for every key. You have sum them manually however.</p>


            <h1 id="examples" class="pagetitle">5. Examples</h1>


            <p class="pagetext">Web forums, news sites, blogs and even websites like reddit can all fit within the same basic hierarchical structure.</p>


            <div class="structure">
                <pre>

Landing page    -> subsection1 -> article1
                                                          article2
                                                          ...
                            -> subsection2 -> ...
                            -> ...
                </pre>
            </div>



            <p class="pagetext">Each level is an actor type. Article actors are what gets changed most frequently and where the scalability and concurrency of ActorDB is most important.</p>
            <p class="pagetext">Landing page contains the current emphasized articles and links to subsections. This is a single actor, but is easily cachable with memcached or varnish.</p>
            <p class="pagetext">Subsection contains titles, ids and other basic information about articles that belong to it.</p>
            <p class="pagetext">Articles cointain the article data (text,links) and comments.</p>

            <h2 id="example_webforum" class="pagesubtitle">5.1 Web Forum</h2>

            <p class="pagetext">Actor types: subforums, threads, users.</p>
            <p class="pagetext">schema.yaml would look like this:</p>


            <div class="structure">
                <pre>
user:
- CREATE TABLE user (id INTEGER PRIMARY KEY, email TEXT, username TEXT, registered_at DATETIME);
- CREATE TABLE mymessages (id INTEGER PRIMARY KEY, threadid INTEGER);

thread:
- CREATE TABLE messages (id INTEGER PRIMARY KEY, txt TEXT, user INTEGER, time DATETIME);

subforum:
- CREATE TABLE threads (id INTEGER PRIMARY KEY, title TEXT, created DATETIME);
                </pre>
            </div>


            <hr class="hr14colorsmalmargin" />

            <h3 class="pagesubtitle">create new thread query:</h3> 
            


            <div class="structure">
                <pre>
ACTOR thread({{uniqid.threadid}}) create;
INSERT INTO messages VALUES ({{uniqid.msgid}}, 'txt', _userid_, datetime('now'));
ACTOR user(_userid_);
INSERT INTO mymessages VALUES ({{uniqid.msgid}},{{uniqid.threadid}});
ACTOR subforum(_subforumid_);
INSERT INTO threads VALUES ({{uniqid.threadid}},'Thread title',datetime('now'))
                </pre>
            </div>


            <p class="pagetext">This query is sent to ActorDB in a single call. Activities line by line:</p>
            <p class="pagetext">
                <ol>
<li>1. Create an actor of type thread with a generated unique integer id named threadid. ACTOR command will either create an actor if it does not exist or switch to that actor and cause all sql statements to be sent to that actor until next ACTOR command.</li>
<li>2. Insert first message into thread.</li>
<li>3. Switch to actor with a known id userid of type user.</li>
<li>4. Insert msg id into his own table of messages.</li>
<li>5. Switch to subforum actor.</li>
<li>6. Insert new thread.</li>
                </ol>
            </p>

            <hr class="hr14colorsmalmargin" />

            <h3 class="pagesubtitle">read thread</h3> 


            <div class="structure">
                <pre>
ACTOR thread(_threadid_);
SELECT * FROM messages LIMIT 30;
                </pre>
            </div>

            
            <hr class="hr14colorsmalmargin" />

           <h3 class="pagesubtitle">post message to existing thread</h3> 
            

            <div class="structure">
                <pre>
ACTOR thread(_threadid_);
INSERT INTO messages VALUES ({{uniqid.msgid}},'I disagree because of reasons.',_userid_,datetime('now'));
ACTOR user(_userid_)
INSERT INTO mymessages VALUES ({{uniqid.msgid}},_threadid_);
                </pre>
            </div>


            <p class="pagetext"></p>

   			<p class="pagetext">&nbsp;</p>
            <p class="pagetext">&nbsp;</p>
            <p class="pagetext">&nbsp;</p>
            <p class="pagetext">&nbsp;</p>
            <p class="pagetext">&nbsp;</p>
            <p class="pagetext">&nbsp;</p>
            <p class="pagetext">&nbsp;</p>
            <p class="pagetext">&nbsp;</p>
            <p class="pagetext">&nbsp;</p>
            <p class="pagetext">&nbsp;</p>
            <p class="pagetext">&nbsp;</p>

        </div>
    </div>
</div>

        <div class="footer">
            <div class="pagewrapper">
                <div class="linkholder">
                    <a href="https://www.github.com/biokoda/actordb" class="link">GitHub</a>
                    <a href="https://github.com/biokoda/actordb/issues" class="link">Issues</a>
                    <a href="https://github.com/biokoda/actordb/blob/master/README.md" class="link marginrightzero">Changelog</a>
                </div>
                <p class="text">Product by Biokoda. <br/ >
                    Licensed under Mozilla Public License 2.0.
                </p>
                <a class="global-footer_logo"></a>        
            </div>
        </div>

        <!--<script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.1/jquery.min.js"></script>-->
        <script>window.jQuery || document.write('<script src="js/vendor/jquery-1.10.1.min.js"><\/script>')</script>
        <script src="js/vendor/bootstrap.min.js"></script>
        <script src="js/vendor/jquery.easypiechart.min.js"></script>
        <script src="js/vendor/modernizr-2.6.2-respond-1.1.0.min.js"></script>
        
        <script type="text/javascript">
            var isAtLeastIE11 = !!(navigator.userAgent.match(/Trident/) && !navigator.userAgent.match(/MSIE/));
            if (isAtLeastIE11) {
                $("html").addClass("ieedge");
            }
            if (navigator.platform.indexOf("Win") != -1 && navigator.userAgent.indexOf("MSIE") != -1 || navigator.platform.indexOf("Win") != -1 && isAtLeastIE11){
                $("html").addClass("iecomm");
            } 
            if (navigator.platform.indexOf("Win") !=-1 && navigator.userAgent.indexOf("Chrome") != -1) {
                $("html").addClass("winchrome");
            }
        </script>
        <script src="js/actordb-website.js"></script>
        <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

          ga('create', 'UA-47379916-1', 'actordb.com');
          ga('send', 'pageview');

        </script>
    </body>
</html>
