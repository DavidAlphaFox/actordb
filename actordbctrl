#!/usr/bin/env escript
-mode(compile).
% -include_lib("wx/include/wx.hrl").


cmds1() ->
  "Supported commands:~ninit (init)~nupdateschema (us)~nupdatenodes (un)~nstat (s)~nhelp (h)~n~n".
cmds() ->
  cmds1()++
  "Stat columns:~n"++
  "allreads - total number of reads since node started~n"++
  "readsnow - number of reads in the past second~n"++
  "allwrites - total number of writes since node started~n"++
  "writesnow - number of writes in the past second~n"++
  "nactors - total number of actors active~n"++
  "nactive - number of actors that have been active in the past second~n"++
  "tmngrs - num_busy_transaction_managers/total_transaction_managers~n".

-define(COMMANDS,
          "Command list:\n"++
          "init - for initializing cluster\n"++
          "us - update schema (from etc/schema.yaml)\n"++
          "un - update nodes (from etc/nodes.yaml)\n"++
          "s - print stats\n"++
          "m - enter management console\n"++
          "h - help\n"++
          "q - for exit\n").

-define(COMMAND_LIST,[<<"init">>,<<"us">>,<<"un">>,<<"s">>,<<"m">>,<<"h">>,<<"q">>]).

dopipe(Req,Resp,Args) ->
    receive
        {_, {data, Data}} ->
            Line = string:tokens(binary_to_list(Data),"\n"),
            case Line of
                ["q"] ->
                    ok;
                _ ->
                    handle_data(Data),
                    dopipe(Req,Resp,Args)
            end;
        X ->
            port_command(Resp, [io_lib:fwrite("~p",[X]),<<"\n">>]),
            io:format("Received ~p~n",[X])
    end.

main(["pipe", Req,Resp|Args]) ->
    ReqPipe = open_port(Req, [in,eof,binary]),
    RespPipe = open_port(Resp, [out,eof,binary]),
    put(resp,RespPipe),
    case Args of
      [] ->
        port_command(RespPipe, [?COMMANDS,<<"\r\n">>]),
        dopipe(ReqPipe, RespPipe, Args);
      _ ->
        handle_data(Args),
        dopipe(ReqPipe, RespPipe, Args)
    end.

handle_data(Args) when is_binary(Args) ->
  handle_data([binary_to_list(Args)]);

handle_data(["init"] = Args) ->
  put(m,false),
  handle_os(Args);
handle_data(["us"] = Args) ->
  put(m,false),
  handle_os(Args);
handle_data(["un"] = Args) ->
  put(m,false),
  handle_os(Args);
handle_data(["s"] = Args) ->
  put(m,false),
  handle_os(Args);
handle_data(["m"] = _Args) ->
  handle_os(["m"]),
  put(m,true),
  port_command(get(resp), [<<"\n\r\n">>,"ActorDB Account Management mode",<<"\n\n\r\n">>]);
handle_data(["h"] = _Args) ->
  put(m,false),
  port_command(get(resp), [?COMMANDS,<<"\r\n">>]);
handle_data([])->
  put(m,false),
  port_command(get(resp), [?COMMANDS,<<"\r\n">>]);
handle_data(Statement) ->
  case get(m) of
    true ->
      Ctx = get(ctx),
      case rpc:call(get(node),actordb_cmd,cmd,[Statement]) of
        Out ->
          file:write_file("out",term_to_binary(Out),[write]),
          print(Ctx,"~p~n",[Out])
      end;
    _ -> handle_data([])
  end.


handle_os(Args)->
  case os:type() of
    {win32,_} ->
      doit(Args,winconsole);
    _ ->
      doit(Args,console)
  end.

doit([_,_] = Args,Ctx) ->
  [] = os:cmd(epmd_path(Ctx) ++ " -daemon"),
  case Args of
    [EtcPath1x,Cmd1] ->
      EtcPath1 = EtcPath1x ++ "/etc"
  end,
  Cmd = set_action(Cmd1,Ctx),
  EtcPath2 = "{{platform_etc_dir}}",
  case filelib:is_file(EtcPath2++"/app.config") of
    true ->
      EtcPath = EtcPath2;
    false ->
      EtcPath = EtcPath1
  end,
  {ok,VmBin} = file:read_file(EtcPath++"/vm.args"),
  Lines = string:tokens(binary_to_list(VmBin),"\r\n"),
  [{node,Node},{myname,Myname}] = parse_args(Lines,[]),
  case net_kernel:hidden_connect_node(Node) of
    true ->
      case net_adm:ping(Node) of
        pang ->
          print(Ctx,"ActorDB not responding~n");
        pong ->
          put(node,Node),
          put(ctx,Ctx),
          ok
      end;
    _X ->
      print(Ctx,"ActorDB not running ~n")
  end,
  case Cmd of
    "m" -> ok;
    "stat" ->
      Ref = make_ref(),
      {ok,Cols} = rpc:call(Node,actordb_cmd,cmd,[stats,describe,ok]),
      [print(Ctx,"~s",[string:right(Val,15,$\s)]) || Val <- tuple_to_list(Cols)],
      print(Ctx,"~n"),
      ok = rpc:call(Node,actordb_cmd,cmd,[stats,stats,{Myname,self(),Ref}]),
      rec_print_stats(Ctx,Ref,Cols);
    _ ->
      case rpc:call(Node,actordb_cmd,cmd,[list_to_atom(Cmd),parse,EtcPath]) of
        {ok,nochange} ->
          print(Ctx,"No changes detected~n");
        {ok,Out} ->
          print(Ctx,"~s~n",[Out]),
          case do_confirmation(Ctx) of
            yes ->
              Result = rpc:call(Node,actordb_cmd,cmd,[list_to_atom(Cmd),commit,EtcPath]),
              print(Ctx,"~s~n",[Result]);
            no ->
              ok
          end;
        {_,E} ->
          print(Ctx,"Error: ~s~n",[E]);
        E ->
          print(Ctx,"Error: ~s~n",[E])
      end
  end;
doit([Cmd],Ctx) ->
  doit([".",Cmd],Ctx).

print(C,F) ->
  print(C,F,[]).
print(console,F,A) ->
  port_command(get(resp), [io_lib:format(F,A),<<"\r\n">>]);
print(winconsole,F,A) ->
  port_command(get(resp), [io_lib:format(F,A),<<"\r\n">>]).

rec_print_stats(Ctx,Ref,Cols) ->
  receive
    {Ref,Vals} ->
      [begin
          case is_integer(Val) of
            true ->
              print(Ctx,"~s",[string:right(integer_to_list(Val),15,$\s)]);
            false ->
              print(Ctx,"~s",[string:right(Val,15,$\s)])
          end
        end || Val <- tuple_to_list(Vals)],
      print(Ctx,"~n"),
      rec_print_stats(Ctx,Ref,Cols)
    after 3000 ->
      ok
  end.

do_confirmation(X) when X == console; X == winconsole ->
  print(X,"Confirm change? (Y/N): "),
  receive
      {_, {data, Data}} ->
        case Data of
          <<"y">> -> yes;
          <<"Y">> -> yes;
          <<"n">> -> no;
          <<"N">> -> no;
          _ -> do_confirmation(X)
        end;
      _ ->
          do_confirmation(X)
  end.

parse_args([" "++Rem|T],L) ->
	parse_args([Rem|T],L);
parse_args(["#"++_|T],L) ->
	parse_args(T,L);
parse_args(["-name " ++ Namestr|T],L) ->
	Curname = rem_spaces(Namestr),
	Myname = setname(Curname),
  case node() == 'nonode@nohost' of
    true ->
      {ok, _} = net_kernel:start([Myname, longnames]);
    _ ->
      ok
  end,
	parse_args(T,[{node,list_to_atom(Curname)},{myname,Myname}|L]);
parse_args(["-sname " ++ Namestr|T],L) ->
	Curname = rem_spaces(Namestr),
  Myname = setname(Curname),
  case node() == 'nonode@nohost' of
    true ->
      {ok, _} = net_kernel:start([Myname, shortnames]);
    _ ->
      ok
  end,
	parse_args(T,[{node,list_to_atom(Curname)},{myname,Myname}|L]);
parse_args(["-setcookie "++N|T],L) ->
	erlang:set_cookie(node(), list_to_atom(rem_spaces(N))),
	parse_args(T,L);
parse_args([_|T],L) ->
  parse_args(T,L);
parse_args([],L) ->
	L.


setname(Namestr) ->
	{MS,S,MiS} = now(),
	Nm = integer_to_list(MS*1000000000000 + S*1000000 + MiS),
	case string:tokens(rem_spaces(Namestr),"@") of
		[_Name,Addr] ->
			list_to_atom(Nm++"@"++Addr);
		[_Name] ->
			list_to_atom(Nm)
	end.

rem_spaces(Str) ->
	lists:filter(fun(X) -> X /= $\s end,Str).

epmd_path(Ctx) ->
  ErtsBinDir = filename:dirname(escript:script_name()),
  Name = "epmd",
  case os:find_executable(Name, ErtsBinDir) of
    false ->
      case os:find_executable(Name) of
        false ->
          print(Ctx,"Could not find epmd.~n");
        GlobalEpmd ->
          GlobalEpmd
      end;
    Epmd ->
      Epmd
  end.

set_action(Cmd1,Ctx)->
  case Cmd1 of
    "m" ->
      "m";
    "us" ->
      "updateschema";
    "un" ->
      "updatenodes";
    "s" ->
      "stat";
    "updateschema" = Cmd ->
      Cmd;
    "updatenodes" = Cmd ->
      Cmd;
    "stat" = Cmd ->
      Cmd;
    "stats" ->
      "stat";
    "init" = Cmd ->
      Cmd;
    _ ->
      case Cmd1 of
        "h" ->
          io:format(cmds());
        "help" ->
          io:format(cmds());
        _ ->
          print(Ctx,"~nInvalid command.~n~n"++cmds())
      end
  end.
